using System;
using System.Drawing;
using System.Windows.Forms;

namespace DrawIt
{
    /// <summary>
    /// What you have to work with:
    /// 
    /// 1) DrawingModel is a class that encapsulates ("hides the unpleasant bits of) the Windows drawing API
    /// (called "GDI+"), to make it easy for you to draw lines and circles on a control (like a Panel).
    /// 
    /// 2) You can find out the methods that DrawingModel provides for you by control-clicking on "DrawingModel"
    /// below, or by opening DrawingModel.cs and looking for "public class DrawingModel".
    /// 
    /// 3) I've set up a DrawingModel on the CanvasPanel for you.  I've also implemented the methods ShowCurrentPlayer1Location()
    /// and ShowCurrentPlayer2Location() so you can see an example of how to use GridDrawingModel.
    /// 
    /// 4) I've set up the DrawIt class to listen to some "mouse events" from the CanvasPanel (MouseDown when the mouse button is
    /// pressed, MouseUp when the mouse button is released, and MouseMoved when the mouse is moved).  You will draw things on the
    /// CanvasPanel in response to those mouse events.
    /// 
    /// Your job:
    /// 
    /// 1) Draw things on the CanvasPanel using the DrawingModel in response to mouse events.
    /// 
    /// Tricks and Gotchas:
    /// 
    /// As is relatively standard for software, the "X" (horizontal) coordinate increases from left to right...
    /// ...and the "Y" (vertical) coordinate increases from TOP to BOTTOM.  The coordinate (0,0) is in the upper left corner of the
    /// thing you are drawing on (such as "canvasPanel").  This is VERY DIFFERENT from a "normal" (i.e. algebraic or geometric)
    /// "Cartesian" coordinate grid, where (0,0) is in the middle of the graph, and the Y (vertical) coordinate increases from bottom
    /// to top.  This is VERY CONFUSING.  I recommend strongly that you sketch out the coordinates on a piece of paper, with 0,0 in the
    /// upper left corner, and the values increasing to the right and downward, before you try to draw using GridDrawingModel.
    /// 
    /// Enjoy!
    /// </summary>

    public partial class DrawIt : Form
    {
        private const int _LINE_WIDTH = 3;

        // This DrawingModel wraps around the CanvasPanel and gives you a simple interface for drawing
        // lines and circles onto it.  This line doesn't actually create a DrawingModel -- we'll do
        // that in the DrawIt constructor below!
        private readonly DrawingModel _canvasModel;

        // A Pen is used by the drawing libraries to actually draw on the screen.  It controls things
        // like color, line width, etc.  We'll create a pen in the DrawIt constructor as well.
        private readonly Pen _pen;

        private static readonly Color _BACKGROUND_COLOR = Color.DarkGray;
        private static readonly Color _COLOR = Color.Red;

        // This is a constructor method for the DrawIt class.  Notice that it has the same name ("DrawIt") as the class,
        // and does not have a return type.  That's how we know it's a constructor method.
        public DrawIt()
        {
            // This may look familiar from last week's "create a Windows Forms application" assignment.
            // It is generated by Visual Studio to do the initial setup of the controls on your Windows Form.
            InitializeComponent();

            // This line creates a new DrawingModel which wraps around and encapsulates 
            // the CanvasPanel, and then stores that DrawingModel into the instance variable 
            // _canvasModel.
            //
            // Since _canvasModel is an "instance variable" (declared as part of the DrawIt
            // class, above), all of the "instance methods" here in DrawIt (also declared as
            // part of the DrawIt class) will be able to see it.  Anything that wants to draw
            // something on the canvas can say _canvasModel.DrawLine() or _canvasModel.DrawCircle() or...
            //
            // I have implemented versions of HandleMouseDown() and HandleMouseMoved() below
            // that draw simple circles on the canvas, and a circular cursor to show where
            // the next circle will be drawn, to illustrate how to use the DrawingModel.
            _canvasModel = new DrawingModel(CanvasPanel);

            // This creates the Pen intance that draws lines on the canvas.
            _pen = new Pen(_COLOR, _LINE_WIDTH);

            // This starts us out with a dark gray background on the canvas (so the user can see
            // where to draw).
            _canvasModel.Clear(_BACKGROUND_COLOR);

            // These three lines add "event handlers" to the canvas so that we get told when the user
            // does something with the mouse.  An "event handler" is just a method that knows how to 
            // respond to an event (something that happened).  You can watch the extra session from
            // this Thursday if you want to see how to create a method like this.
            CanvasPanel.MouseDown += HandleMouseDown;
            CanvasPanel.MouseUp += HandleMouseUp;
            CanvasPanel.MouseMove += HandleMouseMoved;
        }

        // This will draw a circle on the canvas wherever the user clicks the mouse.
        private void HandleMouseDown(object sender, MouseEventArgs e)
        {
            _canvasModel.DrawCircle(_pen, e.Location.X, e.Location.Y, 20);
        }

        private void HandleMouseUp(object sender, MouseEventArgs e)
        {
            // Doesn't do anything yet.
        }

        // This will draw a temporary circle as a "cursor" wherever the user moves
        // the mouse.  This cursor is the same size as the actual circle that will
        // be drawn in HandleMouseDown(), so that the user can know where they are
        // going to be drawing if they click the mouse.
        //
        // This draws a cursor instead of an actual circle because the last parameter
        // to DrawCircle is "true" -- and that parameter is the "isCursor" parameter,
        // which tells the DrawingModel to draw a temporary circle as a cursor, instead
        // of drawing an actual circle.
        private void HandleMouseMoved(object sender, MouseEventArgs e)
        {
            _canvasModel.DrawCircle(_pen, e.Location.X, e.Location.Y, 20, true);
        }

        private void ClearButtonClicked(object sender, EventArgs e)
        {
            _canvasModel.Clear(_BACKGROUND_COLOR);
        }

        private void UndoButtonClicked(object sender, EventArgs e)
        {
            _canvasModel.Undo();
        }

        private void RedoButtonClicked(object sender, EventArgs e)
        {
            _canvasModel.Redo();
        }
    }
}
