using System;
using System.Drawing;
using System.Windows.Forms;

namespace DrawIt
{
    /// <summary>
    /// What you have to work with:
    /// 
    /// 1) DrawingModel is a class that encapsulates ("hides the unpleasant bits of) the Windows drawing API
    /// (called "GDI+"), to make it easy for you to draw lines and circles on a control (like a Panel).
    /// 
    /// 2) You can find out the methods that DrawingModel provides for you by control-clicking on "DrawingModel"
    /// below, or by opening DrawingModel.cs and looking for "public class DrawingModel".
    /// 
    /// 3) I've set up a DrawingModel on the CanvasPanel for you.  I've also implemented the methods ShowCurrentPlayer1Location()
    /// and ShowCurrentPlayer2Location() so you can see an example of how to use GridDrawingModel.
    /// 
    /// 4) I've set up the DrawIt class to listen to some "mouse events" from the CanvasPanel (MouseDown when the mouse button is
    /// pressed, MouseUp when the mouse button is released, and MouseMoved when the mouse is moved).  You will draw things on the
    /// CanvasPanel in response to those mouse events.
    /// 
    /// Your job:
    /// 
    /// 1) Draw things on the CanvasPanel using the DrawingModel in response to mouse events.
    /// 
    /// Tricks and Gotchas:
    /// 
    /// As is relatively standard for software, the "X" (horizontal) coordinate increases from left to right...
    /// ...and the "Y" (vertical) coordinate increases from TOP to BOTTOM.  The coordinate (0,0) is in the upper left corner of the
    /// thing you are drawing on (such as "canvasPanel").  This is VERY DIFFERENT from a "normal" (i.e. algebraic or geometric)
    /// "Cartesian" coordinate grid, where (0,0) is in the middle of the graph, and the Y (vertical) coordinate increases from bottom
    /// to top.  This is VERY CONFUSING.  I recommend strongly that you sketch out the coordinates on a piece of paper, with 0,0 in the
    /// upper left corner, and the values increasing to the right and downward, before you try to draw using GridDrawingModel.
    /// 
    /// Enjoy!
    /// </summary>

    public partial class DrawIt : Form
    {
        private const int _LINE_WIDTH = 3;

        // This DrawingModel wraps around the CanvasPanel and gives you a simple interface for drawing
        // lines and circles onto it.  This line doesn't actually create a DrawingModel -- we'll do
        // that in the DrawIt constructor below!
        private readonly DrawingModel _canvasModel;
        private readonly IUndoRedoActionSource<DrawAction> _actions; 

        // A Pen is used by the drawing libraries to actually draw on the screen.  It controls things
        // like color, line width, etc.  We'll create a pen in the DrawIt constructor as well.
        private readonly Pen _pen;

        // A Pen of a different color to draw the cursor with.
        private readonly Pen _cursorPen;

        private static readonly Color _BACKGROUND_COLOR = Color.DarkGray;
        private static readonly Color _COLOR = Color.Red;
        private static readonly Color _CURSOR_COLOR = Color.AliceBlue;

        // This is a constructor method for the DrawIt class.  Notice that it has the same name ("DrawIt") as the class,
        // and does not have a return type.  That's how we know it's a constructor method.
        public DrawIt()
        {
            // This may look familiar from last week's "create a Windows Forms application" assignment.
            // It is generated by Visual Studio to do the initial setup of the controls on your Windows Form.
            InitializeComponent();

            // This line creates a SimpleDrawActionSource(), which is a class that very minimally
            // implements IUndoRedoActionSource with an action type of DrawAction.
            // This won't support Undo or Redo, so the buttons will always be disabled, but it 
            // will allow us to use the interface (since it has been implemented), and later we can
            // replace it with a more advanced implementation.
            // _actions = new SimpleDrawActionSource();

            // This line creates a BrokenDrawActionSource(), with the behavior
            // we saw at the beginning of class (in DrawIt 1.0).  It appears to
            // allow Undo and Redo, but if you Undo some actions and then
            // start drawing more circles, it redraws the undone actions 
            // before it starts drawing the new circles.
            // _actions = new BrokenDrawActionSource();
            
            // Homework: Create an actual UndoRedoDrawActionSource() and make sure
            // that it has the proper Undo() and Redo() semantics.
            _actions = new UndoRedoDrawActionSource();

            // This line creates a new DrawingModel which wraps around and encapsulates 
            // the CanvasPanel, and then stores that DrawingModel into the instance variable 
            // _canvasModel.
            //
            // Since _canvasModel is an "instance variable" (declared as part of the DrawIt
            // class, above), all of the "instance methods" here in DrawIt (also declared as
            // part of the DrawIt class) will be able to see it.  Anything that wants to draw
            // something on the canvas can say _canvasModel.DrawLine() or _canvasModel.DrawCircle() or...
            //
            // I have implemented versions of HandleMouseDown() and HandleMouseMoved() below
            // that draw simple circles on the canvas, and a circular cursor to show where
            // the next circle will be drawn, to illustrate how to use the DrawingModel.
            _canvasModel = new DrawingModel(CanvasPanel, _actions)
            {
                Background = new DrawBackgroundAction(_BACKGROUND_COLOR)
            };

            // This creates the Pen intance that draws lines on the canvas.
            _pen = new Pen(_COLOR, _LINE_WIDTH);

            // This creates the Pen instance that draws the cursor.
            _cursorPen = new Pen(_CURSOR_COLOR, _LINE_WIDTH);

            // This starts us out with a dark gray background on the canvas (so the user can see
            // where to draw).
            Clear();

            // These three lines add "event handlers" to the canvas so that we get told when the user
            // does something with the mouse.  An "event handler" is just a method that knows how to 
            // respond to an event (something that happened).  You can watch the extra session from
            // this Thursday if you want to see how to create a method like this.
            CanvasPanel.MouseDown += HandleMouseDown;
            CanvasPanel.MouseUp += HandleMouseUp;
            CanvasPanel.MouseMove += HandleMouseMoved;
        }

        // This will draw a circle on the canvas wherever the user clicks the mouse.
        private void HandleMouseDown(object sender, MouseEventArgs e)
        {
            DrawCircle(_pen, e.Location.X, e.Location.Y, 20);
        }

        private void HandleMouseUp(object sender, MouseEventArgs e)
        {
            // Doesn't do anything yet.
        }

        // This will draw a temporary circle as a "cursor" wherever the user moves
        // the mouse.  This cursor is the same size as the actual circle that will
        // be drawn in HandleMouseDown(), so that the user can know where they are
        // going to be drawing if they click the mouse.
        //
        // This draws a cursor instead of an actual circle because the last parameter
        // to DrawCircle is "true" -- and that parameter is the "isCursor" parameter,
        // which tells the DrawingModel to draw a temporary circle as a cursor, instead
        // of drawing an actual circle.
        private void HandleMouseMoved(object sender, MouseEventArgs e)
        {
            DrawCircle(_cursorPen, e.Location.X, e.Location.Y, 20, true);
        }

        private void ClearButtonClicked(object sender, EventArgs e)
        {
            Clear();
        }

        private void Clear()
        {
            _actions.Clear();
            _canvasModel.DrawActionsChanged();
            UpdateUi();
        }

        private void UndoButtonClicked(object sender, EventArgs e)
        {
            _actions.Undo();
            _canvasModel.DrawActionsChanged();
            UpdateUi();
        }

        private void RedoButtonClicked(object sender, EventArgs e)
        {
            _actions.Redo();
            _canvasModel.DrawActionsChanged();
            UpdateUi();
        }

        public virtual void DrawLine(Pen pen, int x1, int y1, int x2, int y2, bool isCursor = false)
        {
            AddDrawAction(isCursor, new DrawLineAction(pen, x1, y1, x2, y2));
        }

        public virtual void DrawCircle(Pen pen, int x, int y, int radius, bool isCursor = false)
        {
            AddDrawAction(isCursor, new DrawCircleAction(pen, x, y, radius));
        }

        private void AddDrawAction(bool isCursor, DrawAction drawCircle)
        {
            if (isCursor)
            {
                _canvasModel.Cursor = drawCircle;
            }
            else
            {
                _actions.Add(drawCircle);
                _canvasModel.DrawActionsChanged();
                UpdateUi();
            }
        }

        private void UpdateUi()
        {
            UndoButton.Enabled = _actions.CanUndo;
            RedoButton.Enabled = _actions.CanRedo;
        }
    }
}
