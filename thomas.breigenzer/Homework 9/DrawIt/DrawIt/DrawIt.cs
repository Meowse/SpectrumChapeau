using System;
using System.Drawing;
using System.Windows.Forms;
using ActionSources;
using SimplifiedDrawingModel;

namespace DrawIt
{
    /// <summary>
    /// What you have to work with:
    /// 
    /// 1) DrawingModel is a class that encapsulates ("hides the unpleasant bits of) the Windows drawing API
    /// (called "GDI+"), to make it easy for you to draw lines and circles on a control (like a Panel).
    /// 
    /// 2) You can find out the methods that DrawingModel provides for you by control-clicking on "DrawingModel"
    /// below, or by opening DrawingModel.cs and looking for "public class DrawingModel".
    /// 
    /// 3) I've set up a DrawingModel on the CanvasPanel for you.  I've also implemented the methods ShowCurrentPlayer1Location()
    /// and ShowCurrentPlayer2Location() so you can see an example of how to use GridDrawingModel.
    /// 
    /// 4) I've set up the DrawIt class to listen to some "mouse events" from the CanvasPanel (MouseDown when the mouse button is
    /// pressed, MouseUp when the mouse button is released, and MouseMoved when the mouse is moved).  You will draw things on the
    /// CanvasPanel in response to those mouse events.
    /// 
    /// Your job:
    /// 
    /// 1) Draw things on the CanvasPanel using the DrawingModel in response to mouse events.
    /// 
    /// Tricks and Gotchas:
    /// 
    /// As is relatively standard for software, the "X" (horizontal) coordinate increases from left to right...
    /// ...and the "Y" (vertical) coordinate increases from TOP to BOTTOM.  The coordinate (0,0) is in the upper left corner of the
    /// thing you are drawing on (such as "canvasPanel").  This is VERY DIFFERENT from a "normal" (i.e. algebraic or geometric)
    /// "Cartesian" coordinate grid, where (0,0) is in the middle of the graph, and the Y (vertical) coordinate increases from bottom
    /// to top.  This is VERY CONFUSING.  I recommend strongly that you sketch out the coordinates on a piece of paper, with 0,0 in the
    /// upper left corner, and the values increasing to the right and downward, before you try to draw using GridDrawingModel.
    /// 
    /// Enjoy!
    /// </summary>

    public partial class DrawIt : Form
    {
        private const int _LINE_WIDTH = 3;

        // This DrawingModel wraps around the CanvasPanel and gives you a simple interface for drawing
        // lines and circles onto it.  This line doesn't actually create a DrawingModel -- we'll do
        // that in the DrawIt constructor below!
        private readonly DrawingModel _canvasModel;
        private readonly IUndoRedoActionSource<IDrawAction> _actions; 

        // A Pen is used by the drawing libraries to actually draw on the screen.  It controls things
        // like color, line width, etc.  We'll create a pen in the DrawIt constructor as well.
        private readonly Pen _drawingPen;

        // A Pen of a different color to draw the cursor with.
        private readonly Pen _cursorPen;
        //private readonly SolidBrush _brush;
        private readonly Brush _brush;

        private static readonly Color _BACKGROUND_COLOR = Color.DarkGray;
        private static readonly Color _COLOR = Color.Red;
        private static readonly Color _CURSOR_COLOR = Color.AliceBlue;
        private Point _startPoint;
        private bool _isDrawing;

        // This is a constructor method for the DrawIt class.  Notice that it has the same name ("DrawIt") as the class,
        // and does not have a return type.  That's how we know it's a constructor method.
        public DrawIt()
        {
            // This may look familiar from last week's "create a Windows Forms application" assignment.
            // It is generated by Visual Studio to do the initial setup of the controls on your Windows Form.
            InitializeComponent();
            _actions = new UndoRedoActionSource<IDrawAction>();
            _actions.ActionsChanged += UpdateUi;
            _actions.ActionsChanged += UpdateClearButton;

            _canvasModel = new DrawingModel(CanvasPanel, _actions)
            {
                Background = new DrawBackgroundAction(_BACKGROUND_COLOR)
            };

            // This creates the Pen intance that draws lines on the canvas.
            _drawingPen = new Pen(_COLOR, _LINE_WIDTH);

            // This creates the Pen instance that draws the cursor.
            _cursorPen = new Pen(_CURSOR_COLOR, _LINE_WIDTH);
            //_brush = new SolidBrush(_COLOR);
            _brush = new SolidBrush(_COLOR);


            // This starts us out with a dark gray background on the canvas (so the user can see
            // where to draw).
            Clear();

            // These three lines add "event handlers" to the canvas so that we get told when the user
            // does something with the mouse.  An "event handler" is just a method that knows how to 
            // respond to an event (something that happened).  You can watch the extra session from
            // this Thursday if you want to see how to create a method like this.
            CanvasPanel.MouseDown += HandleMouseDown;
            CanvasPanel.MouseUp += HandleMouseUp;
            CanvasPanel.MouseMove += HandleMouseMoved;
            CanvasPanel.MouseLeave += HandleMouseLeave;

            KeyDown += HandleKeyDown;
        }

        private void HandleKeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Escape)
            {
                _canvasModel.Cursor = null;
                _isDrawing = false;
            }
        }

        private void HandleMouseLeave(object sender, EventArgs e)
        {
            _canvasModel.Cursor = null;
        }

        private void HandleMouseDown(object sender, MouseEventArgs e)
        {
            // We don't want to actually draw anything (or even a "cursor") here -- we just want
            // to record the start point for the shape.
            _startPoint = new Point(e.Location.X, e.Location.Y);
            _isDrawing = true;
        }

        private void HandleMouseUp(object sender, MouseEventArgs e)
        {
            if (_isDrawing)
            {
                // Here's where we actually draw the shape.  
                var drawAction = GetAction(e, _drawingPen);

                if (drawAction != null)
                {
                    _actions.Add(drawAction);
                }
            }

            // We also hide the cursor (by setting it to null).
            _canvasModel.Cursor = null;
            _isDrawing = false;
        }

        // This will draw a temporary shape as a "cursor" wherever the user moves
        // the mouse.  This cursor is the same size as the actual shape that will
        // be drawn in HandleMouseDown(), so that the user can know where they are
        // going to be drawing if they click the mouse.
        private void HandleMouseMoved(object sender, MouseEventArgs e)
        {

            if (_isDrawing)
            {
                _canvasModel.Cursor = GetAction(e, _cursorPen);
            }
        }

        private IDrawAction GetAction(MouseEventArgs e, Pen pen)
        {
            if (DrawLinesButton.Checked)
            {
                return new DrawLineAction(pen, _startPoint.X, _startPoint.Y, e.Location.X, e.Location.Y);
            }

            if (DrawCirclesButton.Checked)
            {
                //int radius = MathHelpers.GetRadius(_startPoint, new Point(e.Location.X, e.Location.Y));
                //if (radius == 0)
                //{
                //    return null;
                //}
                //return new DrawCircleAction(pen, _startPoint.X, _startPoint.Y, radius);
                return new DrawCircleAction(pen, _startPoint.X, e.Location.X, _startPoint.Y, e.Location.Y);
            }

            if (DrawRectanglesButton.Checked)
            {
                if (FillShapeCheckBox.Checked)
                {
                    return new DrawRectangleAction(pen, _startPoint.X, e.Location.X, _startPoint.Y, e.Location.Y, true);
                }
                return new DrawRectangleAction(pen, _startPoint.X, e.Location.X, _startPoint.Y, e.Location.Y, false);
            }
            
            if (DrawXesButton.Checked)
            {
                return new DrawXesAction(pen, _startPoint.X, e.Location.X, _startPoint.Y, e.Location.Y);
            }

            return null;
        }

        private void ClearButtonClicked(object sender, EventArgs e)
        {
            Clear();
        }

        private void Clear()
        {
            _actions.Clear();

            // We no longer need to call _canvasModel.DrawActionsChanged() here (and everywhere else in this class
            // that we modify the list of drawing actions).  The DrawingModel is now responsible for listening
            // to ActionsChanged events from the _actions model and updating itself accordingly, so we don't
            // need to worry about doing that ourselves.
            // _canvasModel.DrawActionsChanged()

            // We no longer need to call UpdateUi() here (and everywhere else in this class that we modify
            // the list of drawing actions).  We're listening to ActionsChanged events from the _actions
            // model, and calling UpdateUi whenever the actions change, so we will automatically call
            // UpdateUi when we Clear, Undo, Redo, etc. the _actions model.
            // UpdateUi();
        }

        private void UndoButtonClicked(object sender, EventArgs e)
        {
            _actions.Undo();
        }

        private void RedoButtonClicked(object sender, EventArgs e)
        {
            _actions.Redo();
            ClearButton.Enabled = _actions.CanClear;
        }

        private void UpdateUi()
        {
            UndoButton.Enabled = _actions.CanUndo;
            RedoButton.Enabled = _actions.CanRedo;
        }

        private void UpdateClearButton()
        {
            ClearButton.Enabled = _actions.CanClear;
        }
    }
}
