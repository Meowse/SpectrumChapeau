using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Text;
using System.Windows.Forms;
using System.Xml.Serialization;
using ActionSources;
using SimplifiedDrawingModel;

namespace DrawIt
{
    /// <summary>
    /// What you have to work with:
    /// 
    /// 1) DrawingModel is a class that encapsulates ("hides the unpleasant bits of) the Windows drawing API
    /// (called "GDI+"), to make it easy for you to draw lines and circles on a control (like a Panel).
    /// 
    /// 2) You can find out the methods that DrawingModel provides for you by control-clicking on "DrawingModel"
    /// below, or by opening DrawingModel.cs and looking for "public class DrawingModel".
    /// 
    /// 3) I've set up a DrawingModel on the CanvasPanel for you.  I've also implemented the methods ShowCurrentPlayer1Location()
    /// and ShowCurrentPlayer2Location() so you can see an example of how to use GridDrawingModel.
    /// 
    /// 4) I've set up the DrawIt class to listen to some "mouse events" from the CanvasPanel (MouseDown when the mouse button is
    /// pressed, MouseUp when the mouse button is released, and MouseMoved when the mouse is moved).  You will draw things on the
    /// CanvasPanel in response to those mouse events.
    /// 
    /// Your job:
    /// 
    /// 1) Draw things on the CanvasPanel using the DrawingModel in response to mouse events.
    /// 
    /// Tricks and Gotchas:
    /// 
    /// As is relatively standard for software, the "X" (horizontal) coordinate increases from left to right...
    /// ...and the "Y" (vertical) coordinate increases from TOP to BOTTOM.  The coordinate (0,0) is in the upper left corner of the
    /// thing you are drawing on (such as "canvasPanel").  This is VERY DIFFERENT from a "normal" (i.e. algebraic or geometric)
    /// "Cartesian" coordinate grid, where (0,0) is in the middle of the graph, and the Y (vertical) coordinate increases from bottom
    /// to top.  This is VERY CONFUSING.  I recommend strongly that you sketch out the coordinates on a piece of paper, with 0,0 in the
    /// upper left corner, and the values increasing to the right and downward, before you try to draw using GridDrawingModel.
    /// 
    /// Enjoy!
    /// </summary>

    public partial class DrawIt : Form
    {
        //private const int _LINE_WIDTH = 3;
        //dsh make it not constant 
        private int _line_width = 3;

        // This DrawingModel wraps around the CanvasPanel and gives you a simple interface for drawing
        // lines and circles onto it.  This line doesn't actually create a DrawingModel -- we'll do
        // that in the DrawIt constructor below!
        private readonly DrawingModel _canvasModel;
        private readonly IUndoRedoActionSource<IDrawAction> _actions;

        // A Pen is used by the drawing libraries to actually draw on the screen.  It controls things
        // like color, line width, etc.  We'll create a pen in the DrawIt constructor as well.
        //private readonly Pen _drawingPen;
        //dsh using pat's solution for changing color - change from readonly 
        //static readonly makes it a constant for sure - not sure of readonly advantage if not static
        private Pen _drawingPen;
        //dsh add brush
        private Brush _drawingBrush;

        // A Pen of a different color to draw the cursor with.
        //private readonly Pen _cursorPen;
        //dsh change from readonly
        private Pen _cursorPen;

        private static readonly Color _BACKGROUND_COLOR = Color.DarkGray;
        //private static readonly Color _COLOR = Color.Red;
        //dsh change color variable from readonly static to regular loacal variable
        private Color _color = Color.Red;
        private static readonly Color _CURSOR_COLOR = Color.AliceBlue;
        private Point _startPoint;
        private bool _isDrawing;
        //dsh added end point to get snap2grid to work
        private Point _endPoint;
        //dsh separate color for fill
        private Color _fillcolor = Color.Red;
       
        //create list to hold drawing object data needed to recreate objects when session restored
        private List<SessionData> DrawingData = new List<SessionData>();
        //dsh added to report state when saving session
        private bool _shiftKeyFlag;

        // This is a constructor method for the DrawIt class.  Notice that it has the same name ("DrawIt") as the class,
        // and does not have a return type.  That's how we know it's a constructor method.
        public DrawIt()
        {
            // This may look familiar from last week's "create a Windows Forms application" assignment.
            // It is generated by Visual Studio to do the initial setup of the controls on your Windows Form.
            InitializeComponent();

            // This line creates a SimpleDrawActionSource(), which is a class that very minimally
            // implements IUndoRedoActionSource with an action type of IDrawAction.
            // This won't support Undo or Redo, so the buttons will always be disabled, but it 
            // will allow us to use the interface (since it has been implemented), and later we can
            // replace it with a more advanced implementation.
            // _actions = new SimpleActionSource<IDrawAction>();

            // This line creates a BrokenDrawActionSource(), with the behavior
            // we saw at the beginning of class (in DrawIt 1.0).  It appears to
            // allow Undo and Redo, but if you Undo some actions and then
            // start drawing more circles, it redraws the undone actions 
            // before it starts drawing the new circles.
            // _actions = new BrokenActionSource<IDrawAction>();

            // Homework: Create an actual UndoRedoDrawActionSource() and make sure
            // that it has the proper Undo() and Redo() semantics.
            _actions = new UndoRedoActionSource<IDrawAction>();

            // This line says, "I want to listen to ActionsChanged events from this IActionSource.
            // Every time the ActionsChanged event happens, I want my UpdateUi() method to be called.
            //
            // Note the use of "+=" instead of "=".  That's how delegates are assigned to events.  Instead
            // of using "=", which would imply that only one delegate could listen to an event, we use "+=",
            // which basically says "Add my UpdateUi method as a listener to this event, along with any other
            // listeners who are listening to this event."  This is a good thing, because while we're listening
            // to the ActionsChanged event to update our UI, the DrawingModel will be listening to the same
            // ActionsChanged event to know when to redraw.
            //
            // Note also that I did *NOT* put parentheses after the "UpdateUi" in the line below.  Parentheses
            // indicate a method call -- that I'm actually invoking the method.  In this line, I'm NOT invoking
            // UpdateUi.  Instead, I'm talking about it.  I'm actually giving the event a reference to the method,
            // rather than calling the method.  I'm treating "UpdateUi" as if it were just another value, to be
            // assigned.  This is one of the great things about C#: a method can be treated as just another value,
            // assigned to a variable, passed around to another method as a parameter, etc.  It's a very powerful
            // and advanced language feature, which we're using here to set up our "UpdateUi" method as a listener
            // ("delegate") on the ActionsChanged event of our actions model.
            _actions.ActionsChanged += UpdateUi;

            // This adds ANOTHER event handler ("event listener") on the ActionsChanged
            // event of the _actions object.  When the _actions object fires its
            // ActionsChanged event, it will also call UpdateClearButton()
            _actions.ActionsChanged += UpdateClearButton;

            // This line creates a new DrawingModel which wraps around and encapsulates 
            // the CanvasPanel, and then stores that DrawingModel into the instance variable 
            // _canvasModel.
            //
            // Since _canvasModel is an "instance variable" (declared as part of the DrawIt
            // class, above), all of the "instance methods" here in DrawIt (also declared as
            // part of the DrawIt class) will be able to see it.  Anything that wants to draw
            // something on the canvas can say _canvasModel.DrawLine() or _canvasModel.DrawCircle() or...
            //
            // I have implemented versions of HandleMouseDown() and HandleMouseMoved() below
            // that draw simple circles on the canvas, and a circular cursor to show where
            // the next circle will be drawn, to illustrate how to use the DrawingModel.
            _canvasModel = new DrawingModel(CanvasPanel, _actions)
                               {
                                   Background = new DrawBackgroundAction(_BACKGROUND_COLOR)
                               };

            //dsh set background of button to color
            //keep colors in sync until first time changed
            ColorSelectButton.BackColor = _color;
            FillColorSelectButton.BackColor = _fillcolor;
            FillColorSelectButton.Tag = "KeepFillInSync";

            // This creates the Pen intance that draws lines on the canvas.
            _drawingPen = new Pen(_color, _line_width);

            // This creates the Pen instance that draws the cursor.
            _cursorPen = new Pen(_CURSOR_COLOR, _line_width);

            //dsh create brush instance for fill
            _drawingBrush = new SolidBrush(_fillcolor);

            // This starts us out with a dark gray background on the canvas (so the user can see
            // where to draw).
            Clear();

            // These three lines add "event handlers" to the canvas so that we get told when the user
            // does something with the mouse.  An "event handler" is just a method that knows how to 
            // respond to an event (something that happened).  You can watch the extra session from
            // this Thursday if you want to see how to create a method like this.
            CanvasPanel.MouseDown += HandleMouseDown;
            CanvasPanel.MouseUp += HandleMouseUp;
            CanvasPanel.MouseMove += HandleMouseMoved;
            CanvasPanel.MouseLeave += HandleMouseLeave;

            KeyDown += HandleKeyDown;
            //dsh add method listen to event on trackbar
            trackBar1.MouseUp += AdjustLineWidth;
        }

        private void AdjustLineWidth(object sender, EventArgs e)
        {
            GetPenWidth(trackBar1.Value);
        }

        private void HandleKeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Escape)
            {
                _canvasModel.Cursor = null;
                _isDrawing = false;
            }
        }

        private void HandleMouseLeave(object sender, EventArgs e)
        {
            _canvasModel.Cursor = null;
        }

        private void HandleMouseDown(object sender, MouseEventArgs e)
        {
            // We don't want to actually draw anything (or even a "cursor") here -- we just want
            // to record the start point for the shape.
            _startPoint = new Point(e.Location.X, e.Location.Y);
            _isDrawing = true;
        }

        private void HandleMouseUp(object sender, MouseEventArgs e)
        {
            if (_isDrawing)
            {

                // Here's where we actually draw the shape. 
                var drawAction = GetAction(e, _drawingPen);

                // dsh capture all possible values needed to recreate objects
                //how to sync with redo and undo - possibly add an ID to both list
                // don't need to pass everthing if it's already defined like color etc
                //StoreValuesInObjectforPersistance(drawAction);

                if (drawAction != null)
                {
                    _actions.Add(drawAction);
                    StoreValuesInObjectforPersistance(drawAction);
                }
            }

            // We also hide the cursor (by setting it to null).
            _canvasModel.Cursor = null;
            _isDrawing = false;
        }

        // This will draw a temporary shape as a "cursor" wherever the user moves
        // the mouse.  This cursor is the same size as the actual shape that will
        // be drawn in HandleMouseDown(), so that the user can know where they are
        // going to be drawing if they click the mouse.
        private void HandleMouseMoved(object sender, MouseEventArgs e)
        {
            // We don't want to actually draw a shape here, but instead to draw a temporary cursor.
            // So we're going to make a new DrawLineAction or DrawCircleAction, etc., just like in 
            // HandleMouseDown, but instead of adding it to the list of actions, we're going to set it 
            // as the Cursor of the DrawingModel. We'll let the DrawingModel take care of the details of 
            // drawing a cursor (a temporary image) instead of drawing a permanent shape.
            if (_isDrawing)
            {
                _canvasModel.Cursor = GetAction(e, _cursorPen);
            }
        }

        private IDrawAction GetAction(MouseEventArgs e, Pen pen)
        {
            //takes mouse arg e and converts to point / adjusts all points to next 5
            Sanp2Grid(e);


            if (DrawLinesButton.Checked)
            {
                return new DrawLineAction(pen, _startPoint.X, _startPoint.Y, _endPoint.X, _endPoint.Y);
            }

            if (DrawCirclesButton.Checked)
            {
                if (Control.ModifierKeys == Keys.Shift)
                {
                    _shiftKeyFlag=true;

                    if (FillcheckBox.Checked)
                    {
                        return new DrawOvalAction(_drawingBrush, _startPoint.X, _startPoint.Y, _endPoint.X, _endPoint.Y,
                                                  true);
                    }
                    else
                    {
                        return new DrawOvalAction(pen, _startPoint.X, _startPoint.Y, _endPoint.X, _endPoint.Y);
                    }
                }
                else
                {
                    if (FillcheckBox.Checked)
                    {
                        int radius = MathHelpers.GetRadius(_startPoint, new Point(_endPoint.X, _endPoint.Y));
                        if (radius == 0)
                        {
                            return null;
                        }
                        return new DrawCircleAction(_drawingBrush, _startPoint.X, _startPoint.Y, radius, true);
                    }
                    else
                    {
                        int radius = MathHelpers.GetRadius(_startPoint, new Point(_endPoint.X, _endPoint.Y));
                        if (radius == 0)
                        {
                            return null;
                        }
                        return new DrawCircleAction(pen, _startPoint.X, _startPoint.Y, radius);
                    }
                }
            }
            if (DrawRectanglesButton.Checked)
            {
                if (FillcheckBox.Checked)
                {
                    if (Control.ModifierKeys == Keys.Shift)
                    {
                        _shiftKeyFlag = true;
                        //MessageBox.Show("shift key");
                        int diffx = Math.Abs(_startPoint.X - _endPoint.X);
                        int samexy = _startPoint.Y + diffx;
                        return new DrawRectangleAction(_drawingBrush, _startPoint.X, _startPoint.Y, _endPoint.X, samexy,
                                                       true);
                    }

                    return new DrawRectangleAction(_drawingBrush, _startPoint.X, _startPoint.Y, _endPoint.X, _endPoint.Y,
                                                   true);
                }
                else
                {
                    if (Control.ModifierKeys == Keys.Shift)
                    {
                        _shiftKeyFlag = true;
                        //MessageBox.Show("shift key");
                        int diffx = Math.Abs(_startPoint.X - _endPoint.X);
                        int samexy = _startPoint.Y + diffx;
                        return new DrawRectangleAction(pen, _startPoint.X, _startPoint.Y, _endPoint.X, samexy);
                    }

                    return new DrawRectangleAction(pen, _startPoint.X, _startPoint.Y, _endPoint.X, _endPoint.Y);
                }
            }
            if (DrawXesButton.Checked)
            {
                return new DrawXAction(pen, _startPoint.X, _startPoint.Y, _endPoint.X, _endPoint.Y);
            }


            return null;
        }

        //should be able to pass the entire object created from xml file
        private IDrawAction GetActionFromSavedSession(SessionData drawObject)
        {

            // ARBG in a 32 bit integer representing the ARBG values
            // unable to capture the name for all the colors - use arbg values
            _color = Color.FromArgb(drawObject.PenColor_ARBG);
            _fillcolor = Color.FromArgb(drawObject.BrushColor_ARBG);

            //get line width
            _line_width = drawObject.LineWidth;

            //get type pen
            if (drawObject.IsFill)
            {
                _drawingBrush = new SolidBrush(_fillcolor);
            }
            else
            {
                _drawingPen = new Pen(_color, _line_width);
            }

            //get start and end points
            _startPoint.X = drawObject.StartX;
            _startPoint.Y = drawObject.StartY;
            _endPoint.X = drawObject.EndX;
            _endPoint.Y = drawObject.EndY;

            if (drawObject.NameofDrawingAction.Contains("DrawLineAction"))
            {
                return new DrawLineAction(_drawingPen, _startPoint.X, _startPoint.Y, _endPoint.X, _endPoint.Y);
            }


            if (drawObject.NameofDrawingAction.Contains("DrawCircle") || drawObject.NameofDrawingAction.Contains("Oval"))
            {
                //shift key not saved state - no long depressed when action completed so it's not saved as true
                if (drawObject.IsShift)
                {
                    if (drawObject.IsFill)
                    {
                        return new DrawOvalAction(_drawingBrush, _startPoint.X, _startPoint.Y, _endPoint.X, _endPoint.Y,
                                                  true);
                    }
                    else
                    {
                        return new DrawOvalAction(_drawingPen, _startPoint.X, _startPoint.Y, _endPoint.X, _endPoint.Y);
                    }
                }
                else
                {
                        if (drawObject.IsFill)
                    {
                        int radius = MathHelpers.GetRadius(_startPoint, new Point(_endPoint.X, _endPoint.Y));
                        if (radius == 0)
                        {
                            return null;
                        }
                        return new DrawCircleAction(_drawingBrush, _startPoint.X, _startPoint.Y, radius, true);
                    }
                    else
                    {
                        int radius = MathHelpers.GetRadius(_startPoint, new Point(_endPoint.X, _endPoint.Y));
                        if (radius == 0)
                        {
                            return null;
                        }
                        return new DrawCircleAction(_drawingPen, _startPoint.X, _startPoint.Y, radius);
                    }
                }
            }
            if (drawObject.NameofDrawingAction.Contains("Rectangle"))
            {
                if (drawObject.IsFill)
                {
                    if (drawObject.IsShift)
                    {
                        //MessageBox.Show("shift key");
                        int diffx = Math.Abs(_startPoint.X - _endPoint.X);
                        int samexy = _startPoint.Y + diffx;
                        return new DrawRectangleAction(_drawingBrush, _startPoint.X, _startPoint.Y, _endPoint.X, samexy,
                                                       true);
                    }
                            return new DrawRectangleAction(_drawingBrush, _startPoint.X, _startPoint.Y, _endPoint.X, _endPoint.Y,
                                                   true);
                }
                else
                {
                    if (drawObject.IsShift)
                    {
                        //MessageBox.Show("shift key");
                        int diffx = Math.Abs(_startPoint.X - _endPoint.X);
                        int samexy = _startPoint.Y + diffx;
                        return new DrawRectangleAction(_drawingPen, _startPoint.X, _startPoint.Y, _endPoint.X, samexy);
                    }

                    return new DrawRectangleAction(_drawingPen, _startPoint.X, _startPoint.Y, _endPoint.X, _endPoint.Y);
                }
            }
            if (drawObject.NameofDrawingAction.Contains("DrawX"))
            {
                return new DrawXAction(_drawingPen, _startPoint.X, _startPoint.Y, _endPoint.X, _endPoint.Y);
            }


            return null;
        }

        private void Sanp2Grid(MouseEventArgs e)
        {
            //dsh Snap2Grid written at top of getaction and extracted to method / extracted further to AdjustPointUp5
            // round up to nearest 5
            _startPoint.X = AdjustPointUp5(_startPoint.X);
            _startPoint.Y = AdjustPointUp5(_startPoint.Y);
            _endPoint.X = AdjustPointUp5(e.Location.X);
            _endPoint.Y = AdjustPointUp5(e.Location.Y);
        }

        private int AdjustPointUp5(int number)
        {
            int tempnum = number%5;
            int newStart = number;
            if (tempnum > 0)
            {
                newStart = number + (5 - tempnum);
            }
            return newStart;
        }

        private void ClearButtonClicked(object sender, EventArgs e)
        {
            Clear();
        }

        private void Clear()
        {
            _actions.Clear();

            // We no longer need to call _canvasModel.DrawActionsChanged() here (and everywhere else in this class
            // that we modify the list of drawing actions).  The DrawingModel is now responsible for listening
            // to ActionsChanged events from the _actions model and updating itself accordingly, so we don't
            // need to worry about doing that ourselves.
            // _canvasModel.DrawActionsChanged()

            // We no longer need to call UpdateUi() here (and everywhere else in this class that we modify
            // the list of drawing actions).  We're listening to ActionsChanged events from the _actions
            // model, and calling UpdateUi whenever the actions change, so we will automatically call
            // UpdateUi when we Clear, Undo, Redo, etc. the _actions model.
            // UpdateUi();
        }

        private void UndoButtonClicked(object sender, EventArgs e)
        {
            _actions.Undo();
        }

        private void RedoButtonClicked(object sender, EventArgs e)
        {
            _actions.Redo();
            ClearButton.Enabled = _actions.CanClear;
        }

        private void UpdateUi()
        {
            UndoButton.Enabled = _actions.CanUndo;
            RedoButton.Enabled = _actions.CanRedo;
        }

        private void UpdateClearButton()
        {
            ClearButton.Enabled = _actions.CanClear;
        }

        private void ColorSelectButton_Click(object sender, EventArgs e)
        {
            ColorDialog ColorDialog1 = new ColorDialog();
            DialogResult result = ColorDialog1.ShowDialog();
            if (result == DialogResult.OK)
            {
                _color = ColorDialog1.Color;
                ColorSelectButton.BackColor = _color;
                _drawingPen = new Pen(_color, _line_width);
                if (FillColorSelectButton.Tag.ToString() == "KeepFillInSync")
                {
                    _fillcolor = ColorDialog1.Color;
                    FillColorSelectButton.BackColor = _fillcolor;
                    _drawingBrush = new SolidBrush(_fillcolor);
                }


            }
        }

        private void CreateNewPens(int number)
        {
            _line_width = number;
            _drawingPen = new Pen(_color, _line_width);
            _cursorPen = new Pen(_CURSOR_COLOR, _line_width);
        }

        private void GetPenWidth(int number)
        {
            switch (number)
            {
                case 0:
                    {
                        CreateNewPens(1);
                        return;
                    }
                case 1:
                    {
                        CreateNewPens(2);
                        return;
                    }
                case 2:
                    {
                        CreateNewPens(3);
                        return;
                    }
                case 3:
                    {
                        CreateNewPens(5);
                        return;
                    }
                case 4:
                    {
                        CreateNewPens(7);
                        return;
                    }
                case 5:
                    {
                        CreateNewPens(9);
                        return;
                    }
                case 6:
                    {
                        CreateNewPens(11);
                        return;
                    }
                case 7:
                    {
                        CreateNewPens(13);
                        return;
                    }
                case 8:
                    {
                        CreateNewPens(15);
                        return;
                    }
                case 9:
                    {
                        CreateNewPens(17);
                        return;
                    }
                case 10:
                    {
                        CreateNewPens(20);
                        return;
                    }
                default:
                    return;
            }
        }

        private void FillColorSelectButton_Click(object sender, EventArgs e)
        {
            if (FillColorSelectButton.Tag.ToString() == "KeepFillInSync")
            {
                if (
                    MessageBox.Show("Do you want to separate Fill from regular color", "Choose a different Fill Color",
                                    MessageBoxButtons.YesNo) == DialogResult.No)
                {
                    return;
                }
            }
            ColorDialog ColorDialog1 = new ColorDialog();
            DialogResult result = ColorDialog1.ShowDialog();
            if (result == DialogResult.OK)
            {
                _fillcolor = ColorDialog1.Color;
                FillColorSelectButton.BackColor = _fillcolor;
                _drawingBrush = new SolidBrush(_fillcolor);
                FillColorSelectButton.Tag = "";
            }
        }

        public class SessionData
        {
            // class for storing values for persistence - store in xml file

            public String NameofDrawingAction
            { get; set; }

            // gets the 32 bit integer value for the color 
            public int PenColor_ARBG
            { get; set; }

            public int BrushColor_ARBG
            { get; set; }

            //logic
            public bool IsShift
            { get; set; }

            public bool IsFill
            { get; set; }

            //line width
            public int LineWidth
            {get; set; }

            //get start and end points
            public int  StartX
            {get; set; }
            public int  StartY
            {get; set; }
            public int EndX
            {get; set; }
            public int EndY
            { get; set; }

        }

        private void StoreValuesInObjectforPersistance(IDrawAction drawAction)
        {

            //get all the values together and add to an ojbect that can be written to xml
            //on return we will have a method that recreates the list and objects (and list of actions as well)
            SessionData drawObject = new SessionData();
            //get name
            drawObject.NameofDrawingAction = drawAction.ToString();
            //get logic 
            if (_shiftKeyFlag == true)
            {
                drawObject.IsShift = true;
                _shiftKeyFlag = false;
            }
            //if fill use brush
            if (FillcheckBox.Checked)
            {
                drawObject.IsFill = true;
            }

            //get pen and brush color brush
            drawObject.PenColor_ARBG = _color.ToArgb();
            drawObject.BrushColor_ARBG = _fillcolor.ToArgb();

            // get line width
            drawObject.LineWidth = _line_width;

            //get start and end points
            drawObject.StartX = _startPoint.X;
            drawObject.StartY = _startPoint.Y;
            drawObject.EndX = _endPoint.X;
            drawObject.EndY = _endPoint.Y;

            //add object to list of objects
            DrawingData.Add(drawObject);

        }

        private void SaveButton_Click(object sender, EventArgs e)
        {
            // Save to xml the list containing info needed to recreate drawing objects

            SerializeToXML(DrawingData);

        }

        private void SerializeToXML(List<SessionData> data)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(List<SessionData>));
            TextWriter textWriter = new StreamWriter(@"C:\temp\test1.xml");
            serializer.Serialize(textWriter, data);
            textWriter.Close();
        }


        private void RestoreButton_Click(object sender, EventArgs e)
        {
            LoadXMLData();
        }

        private void LoadXMLData()
        {
            ////load data back it works
            
            List<SessionData> newList = new List<SessionData>();
            newList = RecreateObjectsFromSavedList();

            foreach (SessionData drawObject in newList)
            {
                GetActionFromSavedSession(drawObject);

               // this is where we draw the shape and add to list as we restore
               var drawAction = GetActionFromSavedSession(drawObject);

               if (drawAction != null)
               {
                    _actions.Add(drawAction);
               }
                
            }
        }

        private List<SessionData> RecreateObjectsFromSavedList()
        {

            XmlSerializer deserializer = new XmlSerializer(typeof(List<SessionData>));
            TextReader textReader = new StreamReader(@"C:\temp\test1.xml");
            List<SessionData> TextList;
            TextList = (List<SessionData>)deserializer.Deserialize(textReader);
            textReader.Close();

            return TextList;

        }

        
    }
}
